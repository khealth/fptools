from typing import Generic, Mapping, MutableMapping, TypeVar, Generator, Tuple, Iterable, Hashable, Callable, Optional, cast, Union
from copy import copy
from collections.abc import ItemsView
from .callable import curry


M = TypeVar("M", bound=MutableMapping)
K = TypeVar('K')
V = TypeVar('V')
K2 = TypeVar('K2')
V2 = TypeVar('V2')


def create_empty(mapping: M) -> M:
    """
    Create a new mapping of the type of given mapping
    """
    return type(mapping)()


def extract(*keys: K, **aliases: K2):
    from .collection import getitem

    def extractor(mapping: Mapping[K, V]) -> Mapping[Union[K, str], V2]:
        return {
            **{key: getitem(value, mapping) for key, value in aliases.items()},
            **pick(keys, mapping)
        }

    return extractor


@curry
def pick(_items: Iterable[K], mapping: MutableMapping[K, V]) -> MutableMapping[K, Optional[V]]:
    """
    Creates a mapping composed of the picked mapping items.
    """
    next_mapping = cast(MutableMapping[K, Optional[V]], create_empty(mapping))
    for item in _items:
        next_mapping[item] = mapping.get(item)
    return next_mapping


@curry
def omit(_items: Iterable[K], mapping: MutableMapping[K, V]) -> MutableMapping[K, V]:
    """
    Creates a mapping without the omitted mapping items.
    """
    next_mapping = copy(mapping)
    for item in _items:
        try:
            next_mapping.pop(item)
        except KeyError:
            continue
    return next_mapping


@curry
def map_values(modifier: Callable[[V], V2], mapping: MutableMapping[K, V]) -> MutableMapping[K, V2]:
    """
    Creates a dictionary with the same keys as _dict and values generated by applying modifier(val) for each value.
    """
    next_mapping = cast(MutableMapping[K, V2], create_empty(mapping))
    for key, value in mapping.items():
        next_mapping[key] = modifier(value)
    return next_mapping


@curry
def map_keys(modifier: Callable[[K], K2], mapping: MutableMapping[K, V]) -> MutableMapping[K2, V]:
    """
    Creates a dictionary with the same values as _dict and keys generated by applying modifier(key) for each key.
    """
    next_mapping = cast(MutableMapping[K2, V], create_empty(mapping))
    for key, value in mapping.items():
        next_mapping[modifier(key)] = value
    return next_mapping


def is_dict(value):
    """
    Matches if value is a dictionary
    """
    return isinstance(value, dict)


class items(ItemsView, Generic[K, V]):
    """
    Mapping.items() for Mapping like objects that don't implement items()
    """
    _mapping: Mapping[K, V]

    def __init__(self, mapping: Mapping[K, V]):
        self._mapping = mapping

    def __len__(self):
        return self._mapping.__len__()

    def __contains__(self, item):
        return self._mapping.__contains__(item)

    def __iter__(self) -> Generator[Tuple[K, V], None, None]:
        for key in self._mapping:
            yield (key, self._mapping[key])
